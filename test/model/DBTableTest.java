/**
 * 
 */
package model;

import static common.TEST.DEFAULT_TIMEOUT;
import static common.TEST.*;
import static common.TEST.random;
import static org.junit.Assert.*;

import java.math.BigDecimal;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import javax.sql.rowset.RowSetMetaDataImpl;

import org.apache.commons.collections.map.CaseInsensitiveMap;
import org.apache.commons.dbutils.BasicRowProcessor;
import org.apache.commons.lang.ArrayUtils;
import org.apache.commons.lang.StringUtils;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Ignore;
import org.junit.Test;

import tools.ToolBox;

public class DBTableTest {
	static DataBase dataBase;

	static DBTable dbTable;

	String createStmt = "CREATE MEMORY TABLE TESTTABLE"
			+ "(ID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0)"
			+ " NOT NULL PRIMARY KEY,NAME VARCHAR(255),COL2 VARCHAR(255),"
			+ "smallint_col SMALLINT)";

	String createAllTypesTable = "CREATE TABLE ALLSQLTYPES ("
			+ "DOUBLE_Column DOUBLE, TINYINT_Column TINYINT,"
			+ " BOOLEAN_Column BOOLEAN, REAL_Column REAL, "
			+ "BIGINT_Column BIGINT, OTHER_Column OTHER, FLOAT_Column FLOAT, "
			+ "CHAR_Column CHAR, TIMESTAMP_Column TIMESTAMP, "
			+ "VARBINARY_Column VARBINARY, INTEGER_Column INTEGER,"
			+ " BINARY_Column BINARY, LONGVARCHAR_Column LONGVARCHAR,"
			+ " DECIMAL_Column DECIMAL, DATE_Column DATE, VARCHAR_Column VARCHAR,"
			+ " NUMERIC_Column NUMERIC, TIME_Column TIME, LONGVARBINARY_Column"
			+ " LONGVARBINARY, BIT_Column BIT, SMALLINT_Column SMALLINT,"
			+ " NULL_Column NULL);";

	String insertOneRow = "INSERT INTO TESTTABLE (id,name,smallint_col) VALUES (1,'test',1);";

	String insert3Rows = "INSERT INTO TESTTABLE VALUES (1,'test1','value1',1);"
			+ "INSERT INTO TESTTABLE (id,name,smallint_col) VALUES (2,'test2',2);"
			+ "INSERT INTO TESTTABLE (id,name,smallint_col) VALUES (3,'test3',3);";

	/**
	 * @throws java.lang.Exception
	 */
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		dataBase = new DataBase(false, common.TEST.dbURL, common.TEST.dbFile);
	}

	/**
	 * @throws java.lang.Exception
	 */
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		dataBase.shutdownDB();

	}

	/**
	 * @throws java.lang.Exception
	 */
	@Before
	public void setUp() throws Exception {

		dataBase.dropTables();
	}

	/**
	 * @throws java.lang.Exception
	 */
	@After
	public void tearDown() throws Exception {
		dataBase.dropTables();
		// dbTable = null;
	}

	/**
	 * Test method for {@link model.DBTable#getCreateStatement()}.
	 * 
	 * @throws Exception
	 */
	// @Ignore
	@Test
	// (timeout = DEFAULT_TIMEOUT)
	public final void testGetSetCreateStatement() throws Exception {
		// empty DB
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		String returnVal = dbTable.getCreateStatement();
		// test
		assertEquals("createStmt: ", createStmt.toLowerCase(), returnVal
				.toLowerCase());
		// Table already exists
		dbTable = new DBTable("TESTTABLE");
		returnVal = dbTable.getCreateStatement();
		assertEquals("createStmt: ", createStmt.toLowerCase(), returnVal
				.toLowerCase());
	}

	/**
	 * Test method for {@link model.DBTable#getTableName()}.
	 * 
	 * @throws Exception
	 */
	// @Ignore
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testGetSetTableName() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		String returnVal = dbTable.getTableName();
		// test
		assertEquals("tableName: ", "TESTTABLE", returnVal);
	}

	/**
	 * Test method for {@link model.DBTable#createTable(java.lang.String)} &
	 * {@link model.DBTable#dropTable()}.
	 * 
	 * @throws Exception
	 */
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testCreateDropTable() throws Exception {
		// dataBase = new DataBase();
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		// test
		ResultSet rsInsert = dataBase.executeSQL(insertOneRow);
		ResultSet rsSelect = dataBase.executeSQL("select * from TESTTABLE");
		while (rsSelect.next()) {
			// System.out.println(rsSelect.getMetaData());
			assertEquals("ID: ", 1, rsSelect.getInt("Id"));
		}
	}

	/**
	 * Test method for {@link model.DBTable#deleteRows()}.
	 * 
	 * @throws Exception
	 * 
	 */
	// @Ignore
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testDeleteRows() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		ResultSet rs = dataBase.executeSQL(insertOneRow);
		dbTable.deleteRows();
		rs = dataBase.executeSQL("select Count(*) from "
				+ dbTable.getTableName() + ";");

		// test
		// System.out.println(rs.getMetaData());
		rs.next();
		assertEquals("empty Table?: ", 0, rs.getInt(1));
	}

	/**
	 * Test method for {@link model.DBTable#getRowById(int)}.
	 * 
	 * @throws Exception
	 */
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testGetRowById() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		// test
		ResultSet rsInsert = dataBase.executeSQL(insert3Rows);
		ResultSet rsSelect = dataBase.executeSQL("select * from TESTTABLE");
		// MUT
		HashMap returnMap = dbTable.getRowById(2);
		Collection values = returnMap.values();
		Set keys = returnMap.keySet();
		rsSelect.next();
		rsSelect.next();
		for (Object key : keys) {
			// System.out.println("key :" + key);
			Object value = returnMap.get(key);
			// System.out.println("value: " + value);
			// the Test
			assertEquals("Key,Value: ", rsSelect.getObject((String) key),
					returnMap.get(key));
		}
		// cleanUp
		dbTable.deleteRows();
	}

	/**
	 * Test method for {@link model.DBTable#getTableStruct()} &
	 * {@link model.DBTable#setTableStruct()}.
	 * 
	 * @throws Exception
	 */
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testGetSetTableStruct() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		dbTable.setTableStruct(ToolBox.objectMap2ClassNameMap(dbTable
				.getTableStructAsContainerMap()));

		// ResultSet rsInsert = dataBase.executeSQL(insertOneRow);
		String selectStmt = "select * from TESTTABLE";
		ResultSet rsSelect = dataBase.executeSQL(selectStmt);
		HashMap rowMap;
		if (rsSelect.next()) {
			rowMap = dbTable.getRowById(1);
		} else {

			rsSelect = dataBase.executeSQL("DROP TABLE "
					+ dbTable.getTableName() + " IF EXISTS");
			rsSelect = dataBase.executeSQL(createStmt);
			rsSelect = dataBase.executeSQL(selectStmt);
			// BasicRowProcessor.instance().toMap(rsSelect);
			// rowMap = dbTable.getRows()[0];
			// dbTable.deleteRows();
		}
		// MUT
		HashMap<String, String> returnMap = dbTable.getTableStruct();
		Set<String> keys = returnMap.keySet();
		Collection values = returnMap.values();
		// the Test
		ResultSetMetaData rsMetaData = rsSelect.getMetaData();
		// System.out.println(rsMetaData);
		for (int i = 0; i < rsMetaData.getColumnCount(); i++) {
			assertTrue("columnName: " + rsMetaData.getColumnLabel(i + 1), keys
					.contains(rsMetaData.getColumnLabel(i + 1).toLowerCase()));// keys
			if (!rsMetaData.getColumnClassName(i + 1).equals(
					"java.lang.Integer")) { // Integer is only Superset of sqlIntegerTypes
				assertEquals("value Type: ", returnMap.get(rsMetaData
						.getColumnLabel(i + 1).toLowerCase()), rsMetaData
						.getColumnClassName(i + 1));
			}
		}
	}

	/**
	 * Test method for {@link model.DBTable#getRows(int)}.
	 * 
	 * @throws Exception
	 */
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testGetRows() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		// test
		ResultSet rsInsert = dataBase.executeSQL(insert3Rows);
		ResultSet rsSelect = dataBase.executeSQL("select * from TESTTABLE");
		// MUT
		HashMap[] returnMap = dbTable.getRows();
		Integer i = 0;
		while (rsSelect.next()) {
			i++;
			Collection values = returnMap[i - 1].values();
			Set keys = returnMap[i - 1].keySet();
			for (Object key : keys) {
				// System.out.println("key :" + key);
				Object value = returnMap[i - 1].get(key);
				// System.out.println("value: " + value);
				// the Test
				assertEquals("Key,Value: ", rsSelect.getObject((String) key),
						value);
			}
		}
		// cleanUp
		dbTable.deleteRows();
	}

	/**
	 * Test method for {@link model.DBTable#getRowsByWhereCondition(String)}.
	 * 
	 * @throws Exception
	 */
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testGetRowsByWhereCondition() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		// MUT
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		String whereCond = "WHERE NAME LIKE 'test%'";
		// test
		ResultSet rsInsert = dataBase.executeSQL(insert3Rows);
		ResultSet rsSelect = dataBase.executeSQL("select * from TESTTABLE "
				+ whereCond + ";");
		// MUT
		HashMap[] returnMap = dbTable.getRowsByWhereCondition(whereCond);
		Integer i = 0;
		while (rsSelect.next()) {
			i++;
			Collection values = returnMap[i - 1].values();
			Set keys = returnMap[i - 1].keySet();
			for (Object key : keys) {
				// System.out.println("key :" + key);
				Object value = returnMap[i - 1].get(key);
				System.out.println("value: " + value);
				// the Test
				assertEquals("Key,Value: ", rsSelect.getObject((String) key),
						value);
			}
		}
		// cleanUp
		dbTable.deleteRows();
	}

	/**
	 * Test method for {@link model.DBTable#deleteRows()}.
	 * 
	 * @throws Exception
	 * 
	 */
	// @Ignore
	@Test(timeout = DEFAULT_TIMEOUT)
	public final void testColValueFromRow() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		String colName = "col2";
		insertOneRow = "INSERT INTO TESTTABLE (id,name,col2) VALUES (1,'test1','col2');";
		boolean dropFlag = dbTable.dropTable();
		boolean createFlag = dbTable.createTable(createStmt);
		ResultSet rs = dataBase.executeSQL(insertOneRow);
		rs = dataBase.executeSQL("select " + colName + " from "
				+ dbTable.getTableName() + ";");
		HashMap<String, Object> row = dbTable.getRows()[0];
		// MUT
		Object columnValue = dbTable.colValueFromRow(colName, row);
		// the Test
		rs.next();
		System.out.println("columnValue: " + rs.getObject(1));
		assertEquals("columnValue?: ", rs.getObject(1), columnValue);
	}

	/**
	 * Test method for {@link model.DBTable#deleteRows()}.
	 * 
	 * @throws Exception
	 *             TODO test all sql-Types
	 */
	// @Ignore
	@Test
	// (timeout = DEFAULT_TIMEOUT)
	public final void testInsertRow() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		boolean dropFlag = dbTable.dropTable();
		String[] allHSqlTypes = { "INTEGER", "DOUBLE", "VARCHAR", "CHARACTER",
				"LONGVARCHAR", "DATE", "TIME", "TIMESTAMP", "DECIMAL",
				"NUMERIC", "BIT", "TINYINT", "SMALLINT", "BIGINT", "REAL",
				"BINARY", "VARBINARY", "LONGVARBINARY", "OTHER" };
		byte[] bytes = new byte[50];
		random.nextBytes(bytes);

		Object[] allHSqlTypeVals = { Integer.MAX_VALUE, Double.MAX_VALUE,
				"varchar", "c", "LONGVARCHAR", new java.sql.Date(0),
				new java.sql.Time(0), new java.sql.Timestamp(0),
				new java.math.BigDecimal(0), new java.math.BigDecimal(0),
				false, Byte.MAX_VALUE, new Short((short) 9), new Long(8),
				new Double(random.nextDouble()), bytes, bytes, bytes, bytes };
		String columList = "(";
		for (int i = 0; i < allHSqlTypes.length; i++) {
			columList += allHSqlTypes[i].toLowerCase() + "_name "
					+ allHSqlTypes[i];
			if (i != allHSqlTypes.length - 1)
				columList += ", ";
		}
		columList += ")";
		String localCreateStmt = "create table TESTTABLE " + columList + ";";

		boolean createFlag = dbTable.createTable(localCreateStmt);
		String[] keys = new String[allHSqlTypes.length];
		for (int i = 0; i < allHSqlTypes.length; i++) {
			keys[i] = allHSqlTypes[i].toLowerCase() + "_name";
		}
		Object[] values = { 999, "name1", "column2" };
		dbTable.deleteRows();
		// MUT
		dbTable.insertRow(keys, allHSqlTypeVals);
		ResultSet rs = dataBase.executeSQL("select * from "
				+ dbTable.getTableName() + ";");

		// the Test
		// System.out.println(rs.getMetaData());
		rs.next();
		for (int i = 0; i < values.length; i++) {
			assertEquals(keys[i] + ": ", allHSqlTypeVals[i], rs
					.getObject(keys[i]));
		}
	}

	/**
	 * Test method for {@link model.DBTable#getTableStructAsContainerMap() ()}.
	 * 
	 * @throws Exception
	 */
	// @Ignore
	@Test
	// (timeout = DEFAULT_TIMEOUT)
	public final void testGetTableStructAsContainerMap() throws Exception {
		// System.out.print(ToolBox.getCurrentMethodName()+":\n");
		// create all possible db-fields

		dbTable = new DBTable(dataBase, createAllTypesTable);
		// MUT
		HashMap<String, Object> returnVal = dbTable
				.getTableStructAsContainerMap();
		// ToolBox.dumpHahsMap(returnVal);
		// test
		Object[] values = returnVal.values().toArray();
		Collection<Class> expectedClasses = DataBase.JdbcTypes2javaClass
				.values();
		for (int i = 0; i < values.length; i++) {
			Class returnClass = values[i].getClass();
			// System.out.println("returnClass:"+returnClass);
			assertTrue("class: " + returnClass, expectedClasses
					.contains(returnClass));
		}
	}

	/**
	 * Test method for {@link model.DBTable#getTableName()}.
	 * 
	 * @throws Exception
	 */
	// @Ignore
	@Test
	// (timeout = DEFAULT_TIMEOUT)
	public final void testGetIdentity() throws Exception {
		dbTable = new DBTable(dataBase, createStmt);
		HashMap<String, Object> dataMap = randomRowData(dbTable.getTableName());
		dbTable.insertMap2DBTable(dataMap, false);
		HashMap<String, Object> rowById = dbTable.getRowById((Integer) dataMap
				.get("id"));
		int expectedId = (Integer) rowById.get("id");
		// MUT
		Integer returnID = dbTable.getIdentity();
		// test
		assertEquals("tableName: ", expectedId, returnID);
	}

	/**
	 * Test method for
	 * {@link model.DBTable#updateRow(Integer rowID, HashMap<String, Object> dataMap)}.
	 * 
	 * @throws Exception
	 * 
	 * @throws Exception
	 */
	// @Ignore
	@Test
	// (timeout = DEFAULT_TIMEOUT)
	public final void testupdateRow() throws Exception {
		String idPart = "CREATE TABLE ALLSQLTYPES "
				+ "(ID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0) "
				+ "NOT NULL PRIMARY KEY,";
		String createSQL = createAllTypesTable.replaceFirst(
				"CREATE TABLE ALLSQLTYPES \\(", idPart);
		String createStmt = "CREATE MEMORY TABLE TESTTABLE"
				+ "(ID INTEGER GENERATED BY DEFAULT AS IDENTITY(START WITH 0)"
				+ " NOT NULL PRIMARY KEY,varchar_col VARCHAR(255),other_col VARCHAR(255))";
		// createSQL=createStmt;

		dbTable = new DBTable(dataBase, createSQL);
		dbTable.deleteRows();
		HashMap<String, Object> tableDataMap = dbTable
				.getTableStructAsContainerMap();
		// remove-rowID
		tableDataMap = randomRowData(dbTable.getTableName());
		tableDataMap.remove("id");

		String[] keys = tableDataMap.keySet().toArray(new String[0]);
		Object[] values = tableDataMap.values().toArray();
		System.out.println("Arrays.toString(keys): " + Arrays.toString(keys));
		System.out.println("Arrays.toString(values): "
				+ Arrays.toString(values));

		boolean success = dbTable.insertRow(keys, values);

		// MUT
		int rowId = 0;
		HashMap<String, Object> updateData = randomRowData(dbTable.getTableName());
		updateData.put("id", rowId);
		int updateCount = dbTable.updateRowById(dataBase.getConn(), 0,
				updateData);

		// // test
		HashMap<String, Object> returnData = dbTable.getRowById(rowId);
		updateData.put("id", rowId);
		returnData.remove("null_column");
		
//		ToolBox.dumpHahsMap(returnData);
//		ToolBox.dumpHahsMap(updateData);
		System.out.println("returnDataCols: "+Arrays.toString(returnData.keySet().toArray(new String[1])));
		System.out.println("updateDataCols: "+Arrays.toString(updateData.keySet().toArray(new String[1])));
		String[] inputKeys = returnData.keySet().toArray(new String[1]);
		Arrays.sort(inputKeys);
		String[] returnKeys = returnData.keySet().toArray(new String[1]);
		Arrays.sort(returnKeys);
		assertEquals("compare ColNames: ",inputKeys,returnKeys);
		for (int i = 0; i < returnKeys.length; i++) {
			if (!updateData.get(inputKeys[i]).getClass().isArray()) {//only on not nested Types
				assertEquals("compare Vals: ", updateData.get(inputKeys[i]).toString(),
						returnData.get(inputKeys[i]).toString());
			}			
		}
	}

	/**
	 * convenience method: create Random--RowData
	 * 
	 * @throws Exception
	 * 
	 */
	public static HashMap<String, Object> randomRowData(String tableName)
			throws Exception {
		DBTable compTable = new DBTable(tableName);
		HashMap<String, Object> randomRowData = ToolBox.randomRow(compTable
				.getTableStruct());
		return new HashMap<String, Object>(
				new CaseInsensitiveMap(randomRowData));
	}
}
